class Solution:
    def reachNumber(self, target: int) -> int:
        # Work with non-negative target due to symmetry
        target = abs(target)

        # Find smallest k such that 1+2+...+k >= target
        k = 0
        while target > 0:
            k += 1
            target -= k  # target now represents (original_target - sum_{i=1}^k i)

        # If overshoot (which is -target) is even, we can fix by flipping steps
        if target % 2 == 0:
            return k

        # Otherwise, need 1 or 2 more steps to make the difference even
        # If k+1 is odd -> one extra step; if k+1 is even -> two extra steps
        return k + 1 + (k % 2)
