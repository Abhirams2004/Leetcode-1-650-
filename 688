class Solution:
    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        def next_pos(i, j):
            dxdy = [(2, 1), (2, -1), (-2, 1), (-2, -1)]
            dxdy.extend([(y,x) for x,y in dxdy])
            res = [(i+dx, j+dy) for dx,dy in dxdy if i+dx >= 0 and j+dy >=0 and i+dx < n and j+dy < n]
            return res
        map_next = [[next_pos(i, j) for j in range(n)] for i in range(n)]
        prob = [[0 for j in range(n)] for i in range(n)]
        prob[row][column] = 1
        for count in range(k):
            prob2 = [[0 for j in range(n)] for i in range(n)]
            for i in range(n):
                for j in range(n):
                    if prob[i][j] == 0:
                        continue
                    for i2, j2 in map_next[i][j]:
                        prob2[i2][j2] += prob[i][j]/8
            prob = prob2
        return sum([sum(l) for l in prob])
